#!/bin/sh

REACH=${0}
HERE=$(dirname "$(realpath "${REACH}")")

if [ "x${REACH_VERSION}" = "x" ] ; then
    # XXX maybe should be v0.1
    REACH_VERSION=v0.1.1
fi

if ! (which docker docker-compose > /dev/null 2>&1) ; then
    echo "Reach relies on an installation of docker and docker-compose"
    exit 1
fi

do_compile () {
    HS=${HERE}/hs

    # try to lint any args that are .rsh files
    for RSH in "$@"; do
      case "$RSH" in
        *.rsh)
          if [ -f "${RSH}" ]; then
            do_lint "${RSH}" || :
          fi
          ;;
      esac
    done

    # Note: shellcheck says splatting is dangerous,
    # (because what if file names have spaces),
    # but also, sh doesn't have array splicing, so... this.
    # It's a little less mix-and-match
    reachc_release () {
      stack build && \
        stack exec -- \
              reachc "$@"
    }
    reachc_prof () {
      stack build --profile --fast && \
        stack exec --profile -- \
              reachc --disable-reporting --intermediate-files "$@" +RTS -p
    }
    reachc_dev () {
      stack build --fast && \
        stack exec -- \
              reachc --disable-reporting --intermediate-files "$@"
    }

    ID=$(docker info --format '{{.ID}}' 2>/dev/null)
    if [ -z "${REACH_DOCKER}" ] && [ -d "${HS}/.stack-work" ] && (which stack > /dev/null 2>&1) ; then
        export STACK_YAML="${HS}/stack.yaml"
        export REACHC_ID=${ID}
        if [ "x${REACHC_RELEASE}" = "xY" ] ; then
          reachc_release "$@"
        elif [ "x${REACHC_PROFILE}" = "xY" ] ; then
          reachc_prof "$@"
        else
          reachc_dev "$@"
        fi
    else
        cat<<EOF | docker-compose -f - run --rm -e "REACHC_ID=${ID}" reach "$@"
version: '3'
services:
  reach:
    image: reachsh/reach:${REACH_VERSION}
    volumes:
      - $PWD:/app
EOF
    fi
}

do_run () {
    ARG=$1
    cd "$(dirname "$ARG")" || exit
    APP="$(basename "$ARG")"
    RSH="${APP}.rsh"
    MJS="${APP}.mjs"

    if [ "x$APP" = "x" ] ||
           ! [ -f "${RSH}" ] ||
           ! [ -f "${MJS}" ]; then
        echo "Usage: reach-run APP"
        echo "  where APP.rsh"
        echo "    and APP.mjs"
        echo "  exists in current directory."
        exit 1
    fi

    DOCKERFILE=Dockerfile.${APP}
    PACKAGE_JSON=package.json.${APP}

    do_compile -o build "${RSH}" || exit 1

    # XXX Can we add eslint on the JS?
    
    cat >"${PACKAGE_JSON}" <<EOF
{
  "name": "@reach-sh/${APP}",
  "type": "module",
  "dependencies": {
    "@reach-sh/stdlib": "${REACH_VERSION}"
  },
  "author": "reach.sh",
  "license": "Apache-2.0",
  "scripts": {
    "app": "node --experimental-modules --unhandled-rejections=strict ${MJS}"
  }
}
EOF

    # XXX We could optimize this by making reachsh/stdlib-app with everything except the MJS files and make the package linking/install go faster.
    
    cat >"${DOCKERFILE}" <<EOF
FROM reachsh/stdlib:${REACH_VERSION}

WORKDIR /app

COPY package.json.${APP} /app/package.json
RUN npm link '@reach-sh/stdlib'
RUN npm install

COPY ${MJS} /app
RUN mkdir /app/build
COPY build/${APP}.main.mjs /app/build

CMD npm run app
EOF

    docker build -f "${DOCKERFILE}" -t "reachsh/reach-app-${APP}:latest" .
    DOCKER_EXIT=$?

    rm -f "package.json.${APP}" "${DOCKERFILE}"

    if [ $DOCKER_EXIT -ne 0 ] ; then
        exit $DOCKER_EXIT
    fi

    # Note: shellcheck thinks this use of "$@" is weird
    # shellcheck disable=SC2120
    run () {
        docker-compose -f - run --rm reach-app "$@"
    }

    if [ "x${REACH_ETH_MODE}" = "xganache" ] ; then

        cat<<EOF | run
version: '3'
services:
  reach-app:
    image: reachsh/reach-app-${APP}:latest
    environment:
      - ETH_NODE_TYPE=in_memory_ganache
EOF

    else

        cat<<EOF | run
version: '3'
services:
  reach-app:
    image: reachsh/reach-app-${APP}:latest
    depends_on:
      - devnet
    environment:
      - ETH_NODE_URI=http://devnet:8545
  devnet:
    image: reachsh/ethereum-devnet:${REACH_VERSION}
EOF
    fi
}

do_lint () {
  # XXX: make it work outside the repo
  # XXX: make it not require eslint to be installed locally
  # XXX: get it to propagate its error code if run on its own
  if command -v eslint > /dev/null 2>&1; then
    eslint \
      --config "${HERE}/eslint/.eslintrc.yaml" \
      --ext .rsh \
      --no-eslintrc \
      "$@"
  fi
}

SUBCOMMAND=$1
shift

case ${SUBCOMMAND} in
    compile)
        do_compile "$@"
        ;;
    run)
        do_run "$@"
        ;;
    lint)
        do_lint $@
        ;;
    upgrade)
        NEW=reach.$$
        curl https://raw.githubusercontent.com/reach-sh/reach-lang/master/reach -o ${NEW} && \
            chmod +x ${NEW} && \
            cp -f ${NEW} "${REACH}"
        exit 0
        ;;
    update)
        docker pull "reachsh/reach:${REACH_VERSION}"
        docker pull "reachsh/stdlib:${REACH_VERSION}"
        docker pull "reachsh/ethereum-devnet:${REACH_VERSION}"
        exit 0
        ;;
    version)
        echo "reach ${REACH_VERSION}"
        exit 0
        ;;
    *)
        echo "Usage: reach COMMAND"
        echo " where COMMAND is one of"
        echo "  compile --- compile an app"
        echo "  run     --- run a simple app"
        echo "  upgrade --- upgrade Reach"
        echo "  update  --- update Reach Docker images"
        echo "  version --- display version"
        exit 0
        ;;
esac
